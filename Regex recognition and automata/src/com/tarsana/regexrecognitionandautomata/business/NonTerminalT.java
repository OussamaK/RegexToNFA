package com.tarsana.regexrecognitionandautomata.business;

import java.util.ArrayList;
import java.util.List;

import com.tarsana.regexrecognitionandautomata.utils.Accepteur;
import com.tarsana.regexrecognitionandautomata.utils.Triplet;

public class NonTerminalT {

	/**
	 * The list of the relations generated by this non terminal.
	 */
	private List<Triplet> listeRelations;

	/**
	 * The maximum number given to any state.
	 */
	private Integer max;

	/**
	 * The list of the accepting states generated by this non terminal.
	 */
	private List<Accepteur> listeAccepteurs;

	/**
	 * the starting state generated by this non terminal.
	 */
	private Integer debut;

	/**
	 * @return the debut
	 */
	public Integer getDebut() {
		return debut;
	}

	/**
	 * @param debut
	 *            the debut to set
	 */
	public void setDebut(Integer debut) {
		this.debut = debut;
	}

	/**
	 * @return the listeRelations
	 */
	public List<Triplet> getListeRelations() {
		return listeRelations;
	}

	/**
	 * @param listeRelations
	 *            the listeRelations to set
	 */
	public void setListeRelations(List<Triplet> listeRelations) {
		this.listeRelations = listeRelations;
	}

	/**
	 * @return the max
	 */
	public Integer getMax() {
		return max;
	}

	/**
	 * @param max
	 *            the max to set
	 */
	public void setMax(Integer max) {
		this.max = max;
	}

	/**
	 * @return the listeAccepteurs
	 */
	public List<Accepteur> getListeAccepteurs() {
		return listeAccepteurs;
	}

	/**
	 * @param listeAccepteurs
	 *            the listeAccepteurs to set
	 */
	public void setListeAccepteurs(List<Accepteur> listeAccepteurs) {
		this.listeAccepteurs = listeAccepteurs;
	}

	public NonTerminalT() {
		NonTerminalM M = new NonTerminalM();
		NonTerminalD D = new NonTerminalD();

		this.listeAccepteurs = new ArrayList<>();
		this.listeRelations = new ArrayList<>();

		// the call to D resulted in an AND operation.
		// This operation must be calculated here. In this operation ,
		// the left side operands are provided by M , the right side
		// operands by D.
		if (D.getAnd()) {

			// add all the left side operands , no change.
			listeRelations.addAll(M.getListeRelations());
			// Add all the right side operands after adding the max
			// value of the left side to all the state numbers.
			for (Triplet triplet : D.getListeRelations()) {
				triplet.setOrigin(triplet.getOrigin() + M.getMax());
				triplet.setTarget(triplet.getTarget() + M.getMax());
				this.listeRelations.add(triplet);
			}

			// every accepting state from the left side is linked to all
			// the accepting states from the right side.
			for (Accepteur accepteurD : D.getListeAccepteurs()) {
				accepteurD.setState(accepteurD.getState() + M.getMax());
				this.listeAccepteurs.add(accepteurD);
				for (Accepteur accepteurM : M.getListeAccepteurs()) {
					this.listeRelations.add(new Triplet(accepteurM.getState(),
							accepteurD.getSymbol(), accepteurD.getState()));
				}
			}

			// the max from this operation is the right hand side's max.
			this.max = D.getMax() + M.getMax();
			// the start from this operation is the start of the left
			// hand side.
			this.debut = M.getDebut();

		}
		// the call to D did not produce any AND operations.
		// Copy everything from M to the current non terminal.
		else {

			this.listeRelations.addAll(M.getListeRelations());
			this.debut = M.getDebut();
			this.max = M.getMax();
			this.listeAccepteurs.addAll(M.getListeAccepteurs());
		}

	}
}
